â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Scan Status â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  Scanning 1824 files tracked by git with 1053 Code rules:

  Language      Rules   Files          Origin      Rules
 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  <multilang>      62    1792          Community    1053
  js              157      13
  java            117      13
  html              1       8
  yaml             31       6
  json              4       6
  dockerfile        5       2
  ruby             71       1

Warning: 1 timeout error(s) in src/main/resources/static/vendors/bootstrap/js/bootstrap.bundle.js when running the
following rules: [javascript.aws-lambda.security.tainted-html-string.tainted-html-string]


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 26 Code Findings â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    Dockerfile
   â¯â¯â± dockerfile.security.missing-user-entrypoint.missing-user-entrypoint
          By not specifying a USER, a program in the container may run as 'root'. This is a security hazard.
          If an attacker can control a process running as root, they may have control over the container.
          Ensure that the last USER in a Dockerfile is a USER other than 'root'.
          Details: https://sg.run/k281

           â–¶â–¶â”† Autofix â–¶ USER non-root ENTRYPOINT ["java", "-jar", "/app.jar"]
           22â”† ENTRYPOINT ["java", "-jar", "/app.jar"]

    src/main/resources/static/vendors/bootstrap/js/bootstrap.bundle.js
    â¯â± javascript.lang.security.audit.detect-non-literal-regexp.detect-non-literal-regexp
          RegExp() called with a `configTypes` function argument, this might allow an attacker to cause a
          Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main
          thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on
          user-controlled input, consider performing input validation or use a regex checking/sanitization
          library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear
          vulnerable to ReDoS.
          Details: https://sg.run/gr65

          213â”† if (!new RegExp(expectedTypes).test(valueType)) {
            â‹®â”†----------------------------------------
    â¯â± javascript.lang.security.audit.detect-non-literal-regexp.detect-non-literal-regexp
          RegExp() called with a `property` function argument, this might allow an attacker to cause a Regular
          Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For
          this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-
          controlled input, consider performing input validation or use a regex checking/sanitization library
          such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to
          ReDoS.
          Details: https://sg.run/gr65

          213â”† if (!new RegExp(expectedTypes).test(valueType)) {

   â¯â¯â± javascript.browser.security.insecure-document-method.insecure-document-method
          User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern
          that can lead to XSS vulnerabilities
          Details: https://sg.run/LwA9

          5547â”† element.innerHTML = this._config.template;
            â‹®â”†----------------------------------------
          5583â”† element.innerHTML = content;

    src/main/resources/static/vendors/bootstrap/js/bootstrap.esm.js
    â¯â± javascript.lang.security.audit.detect-non-literal-regexp.detect-non-literal-regexp
          RegExp() called with a `configTypes` function argument, this might allow an attacker to cause a
          Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main
          thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on
          user-controlled input, consider performing input validation or use a regex checking/sanitization
          library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear
          vulnerable to ReDoS.
          Details: https://sg.run/gr65

          209â”† if (!new RegExp(expectedTypes).test(valueType)) {
            â‹®â”†----------------------------------------
    â¯â± javascript.lang.security.audit.detect-non-literal-regexp.detect-non-literal-regexp
          RegExp() called with a `property` function argument, this might allow an attacker to cause a Regular
          Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For
          this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-
          controlled input, consider performing input validation or use a regex checking/sanitization library
          such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to
          ReDoS.
          Details: https://sg.run/gr65

          209â”† if (!new RegExp(expectedTypes).test(valueType)) {

   â¯â¯â± javascript.browser.security.insecure-document-method.insecure-document-method
          User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern
          that can lead to XSS vulnerabilities
          Details: https://sg.run/LwA9

          3789â”† element.innerHTML = this._config.template;
            â‹®â”†----------------------------------------
          3825â”† element.innerHTML = content;

    src/main/resources/static/vendors/bootstrap/js/bootstrap.js
    â¯â± javascript.lang.security.audit.detect-non-literal-regexp.detect-non-literal-regexp
          RegExp() called with a `configTypes` function argument, this might allow an attacker to cause a
          Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main
          thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on
          user-controlled input, consider performing input validation or use a regex checking/sanitization
          library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear
          vulnerable to ReDoS.
          Details: https://sg.run/gr65

          235â”† if (!new RegExp(expectedTypes).test(valueType)) {
            â‹®â”†----------------------------------------
    â¯â± javascript.lang.security.audit.detect-non-literal-regexp.detect-non-literal-regexp
          RegExp() called with a `property` function argument, this might allow an attacker to cause a Regular
          Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For
          this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-
          controlled input, consider performing input validation or use a regex checking/sanitization library
          such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to
          ReDoS.
          Details: https://sg.run/gr65

          235â”† if (!new RegExp(expectedTypes).test(valueType)) {

   â¯â¯â± javascript.browser.security.insecure-document-method.insecure-document-method
          User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern
          that can lead to XSS vulnerabilities
          Details: https://sg.run/LwA9

          3815â”† element.innerHTML = this._config.template;
            â‹®â”†----------------------------------------
          3851â”† element.innerHTML = content;

    src/main/resources/static/vendors/fontawesome/js/fontawesome.js
   â¯â¯â± javascript.browser.security.insecure-document-method.insecure-document-method
          User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern
          that can lead to XSS vulnerabilities
          Details: https://sg.run/LwA9

          630â”† style.innerHTML = css;
            â‹®â”†----------------------------------------
          1360â”† node.outerHTML = newOuterHTML + (config.keepOriginalSource && node.tagName.toLowerCase()
               !== 'svg' ? "<!-- ".concat(node.outerHTML, " Font Awesome fontawesome.com -->") : '');
            â‹®â”†----------------------------------------
          1364â”† newNode.outerHTML = newOuterHTML;

    â¯â± javascript.lang.security.audit.detect-non-literal-regexp.detect-non-literal-regexp
          RegExp() called with a `_ref` function argument, this might allow an attacker to cause a Regular
          Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For
          this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-
          controlled input, consider performing input validation or use a regex checking/sanitization library
          such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to
          ReDoS.
          Details: https://sg.run/gr65

          1376â”† var forSvg = new RegExp("".concat(config.familyPrefix, "-.*"));

   â¯â¯â± javascript.browser.security.insecure-document-method.insecure-document-method
          User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern
          that can lead to XSS vulnerabilities
          Details: https://sg.run/LwA9

          1397â”† node.innerHTML = newInnerHTML;
            â‹®â”†----------------------------------------
          2056â”† element.outerHTML = abstract.map(function (a) {
          2057â”†   return toHtml(a);
          2058â”† }).join('\n');
            â‹®â”†----------------------------------------
          2190â”† container.innerHTML = val.html;

    src/main/resources/static/vendors/jquery-mask/Dockerfile
   â¯â¯â± dockerfile.security.missing-user.missing-user
          By not specifying a USER, a program in the container may run as 'root'. This is a security hazard.
          If an attacker can control a process running as root, they may have control over the container.
          Ensure that the last USER in a Dockerfile is a USER other than 'root'.
          Details: https://sg.run/Gbvn

           â–¶â–¶â”† Autofix â–¶ USER non-root CMD ["/sbin/my_init"]
            4â”† CMD ["/sbin/my_init"]

    â¯â± dockerfile.security.no-sudo-in-dockerfile.no-sudo-in-dockerfile
          Avoid using sudo in Dockerfiles. Running processes as a non-root user can help  reduce the potential
          impact of configuration errors and security vulnerabilities.
          Details: https://sg.run/80Q7

           32â”† RUN curl --silent --location https://deb.nodesource.com/setup_0.12 | sudo bash -

    src/main/resources/static/vendors/jquery-mask/deploy.rb
    â¯â± ruby.lang.security.dangerous-subshell.dangerous-subshell
          Detected non-static command inside `...`. If unverified user data can reach this call site, this is
          a code injection vulnerability. A malicious actor can inject a malicious script to execute arbitrary
          code.
          Details: https://sg.run/NrxL

           44â”† `git commit -am 'generating jquery mask files #{JMASK_VERSION}'`

    src/main/resources/static/vendors/jquery-mask/src/jquery.mask.js
    â¯â± javascript.lang.security.audit.detect-non-literal-regexp.detect-non-literal-regexp
          RegExp() called with a `mask` function argument, this might allow an attacker to cause a Regular
          Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For
          this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-
          controlled input, consider performing input validation or use a regex checking/sanitization library
          such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to
          ReDoS.
          Details: https://sg.run/gr65

          165â”† r = r.replace(new RegExp('(' + oRecursive.digit + '(.*' + oRecursive.digit + ')?)'),
               '($1)?')
            â‹®â”†----------------------------------------
          166â”† .replace(new RegExp(oRecursive.digit, 'g'), oRecursive.pattern);
            â‹®â”†----------------------------------------
          169â”† return new RegExp(r);



â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Scan Summary â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Some files were skipped or only partially analyzed.
  Scan was limited to files tracked by git.
  Partially scanned: 1 files only partially analyzed due to parsing or internal Semgrep errors
  Scan skipped: 3 files larger than 1.0 MB, 29 files matching .semgrepignore patterns
  For a full list of skipped files, run semgrep with the --verbose flag.

Ran 443 rules on 1792 files: 26 findings.

ğŸ“¢ Too many findings? Try Semgrep Pro for more powerful queries and less noise.
   See https://sg.run/false-positives.
